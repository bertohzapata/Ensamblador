ASSUME CS:CODIGO, DS:DATOS, SS:PILA

;DADO UN VECTOR DE 10 ELEMENTOS DE 16 BITS CADA UNO DETERMINE QUÉ ELEMENTO ES EL MÁXIMO DE LA LISTA E IMPRIMIR EL RESULTADO EN HEXADECIMAL
;	ADEMÁS EL VECTOR TIENE QUE ADMITIR NÚMEROS REPETIDOS:
;(La lógica de este programa está en el cuaderno)

;A TENER EN CUENTA:	*SE HACE DIRECCIONAMIENTO INDIRECTO MEDIANTE EL REGISTRO BX.
;					*BX TIENE COMO FUNCIÓN SER EL ÍNDICE DEL VECTOR Y SE UTILIZA UNA NOMENCLATURA VECTORIAL: VECTOR[i].
;					*EN ESTE CASO, DE ELEMENTOS DE 16 BITS, EL INCREMENTO DE BX VA DE 2 EN 2 DEBIDO A QUE LOS ELEMENTOS DEL VECTOR SON DE 16 BITS (LÍNEA 24).
;					*UN VECTOR EN ENSAMBLADOR SE PUEDE HACER DE DOS FORMAS: COMO LA QUE SE HACE EN ESTE CÓDIGO O COMO LA QUE SE HACE EN EL CÓDIGO ALMVEC.ASM
;					*ESTE CÓDIGO TAMBIÉN FUNCIONA CON UN VECTOR DE ELEMENTOS DE 8 BITS.
;					*IMPORTANTE INICIALIZAR A BX (índice del vector) EN LA DIRECCIÓN EN MEMORIA DE LA VARIABLE VECTOR MEDIANTE EL USO DE OFFSET (LÍNEA 18).
;					*EL CICLO FOR (LOOP) EMPIEZA EN CERO Y TERMINA EN (TAMAÑO_VECTOR-1) (LÍNEA 20).
;					*EN LA LÍNEA 25 SE DEFINE EL SOPORTE PARA NÚMEROS REPETIDOS, MEDIANTE 'MAYOR O IGUAL'.
;					*NO TIENE QUE SER UN VECTOR DE 10 ELEMENTOS, PUEDE SER DE MÁS. SÓLO HAY QUE MODIFICAR EL CICLO FOR Y AGREGAR MÁS ELEMENTOS AL VECTOR.

CODIGO SEGMENT	
	MOV AX,DATOS
	MOV DS,AX
	
	MOV BX, OFFSET VECTOR
	MOV CX, 9				;EL CICLO FOR VA DE 0 A 9.
	MOV DX, VECTOR[BX]		;EL RESULTADO O NÚMERO MAYOR DEL VECTOR SE ALMACENA EN DX.
CICLO:
	CMP DX, VECTOR[BX+2]	;EL INCREMENTO DE BX VA DE 2 EN 2.
	JAE ETIQ1				;EL MAYOR O IGUAL (JAE) ES PARA QUE SE PUEDA INCLUIR LAS REPETICIONES DEL NÚMERO MAYOR SIN AFECTAR EL RESULTADO.
	MOV DX, VECTOR[BX+2]
ETIQ1:
	ADD BX, 2				;EL INCREMENTO DE BX VA DE 2 EN 2.
	LOOP CICLO
	MOV H, DX				;LA VARIABLE H TOMA EL VALOR DE DX (DONDE ESTÁ ALMACENADO EL RESULTADO) Y SE PROCEDE A IMPRIMIR.
	CALL TRANSFORMAR
	MOV AH, 4CH
	INT 21H     
			
			;PREVIAMENTE EL VALOR A CONVERTIR DEBE DE ESTAR ALMENADO EN LA VARIABLE H:
			TRANSFORMAR PROC
				MOV AH, 09H
				LEA DX, MENSAJE
				INT 21H
				MOV DX, H			
				AND DX, A			;EL AND HACE QUE LOS DEMÁS DÍGITOS SE VUELVAN CERO Y SÓLO QUEDE EL DÍGITO DE LA POSICIÓN QUE SE DESEA IMPRIMIR.
				ROR DX, 12			;SE HACE LA ROTACIÓN PARA QUE EL DÍGITO QUE SE DESEA IMPRIMIR QUEDE JUSTO EN LA ESQUINA DERECHA, PARTE BAJA DE DX.
				CALL IMPRIMIR_HEXADECIMAL
				MOV DX, H			
				AND DX, B
				ROR DX, 8
				CALL IMPRIMIR_HEXADECIMAL
				MOV DX, H			
				AND DX, D
				ROR DX, 4
				CALL IMPRIMIR_HEXADECIMAL
				MOV DX, H			
				AND DX, E
				;ROR DX, 0			;LA ROTACIÓN DE BITS A LA DERECHA VA DECREMENTANDO DE 4 EN 4.
				CALL IMPRIMIR_HEXADECIMAL
				RET
			TRANSFORMAR ENDP
	
			;SUBRUTINA QUE IMPRIME UN NÚMERO EN HEXADECIMAL 
			IMPRIMIR_HEXADECIMAL PROC		
				CMP DL, 09H
				JG IMPHEXA1
				ADD DL, 30H		;EN EL CASO QUE SE DEBA IMPRIMIR UN DÍGITO ENTRE 0 Y 9.
				JMP IMPHEXA2
			IMPHEXA1:
				ADD DL, 37H		;EN EL CASO QUE SE DEBA IMPRIMIR UN DÍGITO ENTRE A Y F.
			IMPHEXA2:
				MOV AH, 2H
				INT 21H
				RET
			IMPRIMIR_HEXADECIMAL ENDP  
CODIGO ENDS

PILA SEGMENT STACK
	DW 32 DUP (0)
PILA ENDS

DATOS SEGMENT
;VECTOR DE TAMAÑO 10:
VECTOR DW 12, 21563, 21563, 65110, 120, 21563, 12, 14752, 65110, 21563
;VARIABLES DE LA SUBRUTINA IMPRIMIR_HEXADECIMAL:
H DW 0H	
A DW 0F000H
B DW 00F00H
D DW 000F0H
E DW 0000FH
MENSAJE DB "EL RESULTADO ES: $"
DATOS ENDS

END
